;;  -*- coding: utf-8-unix; -*- 
(ns xducer-clj.core
  (:use [xducer-clj.semiring])
  (:use [clojure.set]) 
  (:use [clojure.tools.logging]))

(def Transducer
  "A Transducer is a hash map with the following elements:
   - :states is the set of all states 
   - :end is the set of terminal states
   - :delta is a set of transitions, each being itself a hash with
      - a :from/:to state
      - a :in/:out tokens"
  (create-struct 
   :from
   :to
   :in
   :out))


(defmacro dbg 
  "provide debugging trace for a given expression"
  [x] 
  `(let [x# ~x] (debug "dbg:" '~x "=" x#) x#))

(defn transitions-from
  [xducer current-state]
  (filter #(= (:from %) current-state) 
          (:delta xducer)))

(defn match
  [xducer token transition]
  (let [compar (:compare-with xducer)
        input  (:in transition)]
    (cond
     compar          (apply compar input token []) 
     (= :any input)  true
     (= :else input) (not (some #(= token %) 
                                (map :in (transitions-from xducer (:from transition)))))
     :else           (= input token))))

(defn fireable-transitions
  [xducer current-state token]
  (filter #(match xducer token %)
          (transitions-from xducer current-state)))

(defn augment-output
  [state trans]
  (if-let [out (:out trans)]
    (conj (:output state) out)
    (:output state)
    ))

(defn reset-state
  [position xducer current-state]
  (if (:init-on-error xducer)
    {:state 0 :begin (inc position) :length 0 :output []}
    {:state (:state current-state) :begin (inc position) :length 0 :output (:output current-state)}))

(defn apply-fireable-transitions
  [position transitions current-state]
  (loop [fireable transitions 
         output []] 
    (if (seq fireable) 
      (recur (rest fireable) 
             (let [new-output (augment-output current-state (first  fireable))]
               (conj output  
                     {:state  (:to (first fireable))
                      :begin (:begin current-state)
                      :length (inc (:length current-state))
                      :output new-output})))
      output
      )))

(defn fire-transition
  "fires all fireable transitions given a transducer, a state which is
  a hash {:state, :out} and a token.  outputs a list of states of the same
  form."
  [position xducer token current-state]
  (let [transitions (fireable-transitions xducer (:state current-state) token)]
    (if (seq transitions)
      (apply-fireable-transitions position transitions current-state)
      [(reset-state position xducer current-state)]
      )))

(defn complete-to-init
  "transform the input xducer by 'adding' transitions from all states
  back to initial state for unspecified input tokens."
  [xducer]
  (assoc xducer :init-on-error true))

(defn collect-all-outputs
  [current-states end]
  (map (fn [state] {:begin (:begin state) :length (:length state) :output (:output state)})
       (filter #(some #{(:state %)} end) current-states)))

(defn compute-new-states
  [xducer position token current-states]
  (mapcat (partial fire-transition position xducer token) current-states))

(defn xduce
  "Transforms an input stream using a rational transducer.

  Outputs a list of matching positions in the input stream with the following
  structure:
   - :begin position (0-based) in the stream which matched
   - :length of input matching 
   - :output generated by xducer when matching"
  [xducer input]
  (loop [current-states [{:state 0 :begin 0 :length 0 :output []}]
         position 0
         stream input]
    (if (seq stream)
      (let [out (compute-new-states xducer position (first stream) current-states) ]
        (recur out (inc position) (rest stream)))
      (collect-all-outputs current-states (:end xducer)))))

(defn xduce-outputs
  "Transforms an input stream using a rational transducer.
  Returns a collection of all the generated outputs. 

  See (xduce [xducer input]) for
  a more general function returning matched positions."
  [xducer input]
  (map :output (xduce xducer input)))
